{"version":3,"sources":["../../../../../src/.internal/charts/venn/VennDefaultTheme.ts","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/blas1.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/nelderMead.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/linesearch.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/conjugateGradient.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/circleintersection.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/layout.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/fmin/bisect.js","../node_modules/@amcharts/amcharts5/.internal/charts/venn/vennjs/diagram.js","../../../../../src/.internal/charts/venn/Venn.ts"],"names":["VennDefaultTheme","Theme","setupDefaultRules","super","r","this","rule","bind","setAll","legendLabelText","legendValueText","colors","ColorSet","new","_root","width","p100","height","text","populateText","centerX","p50","centerY","zeros","x","Array","i","zerosM","y","map","dot","a","b","ret","length","norm2","Math","sqrt","scale","value","c","weightedSum","w1","v1","w2","v2","j","nelderMead","f","x0","parameters","maxDiff","maxIterations","nonZeroDelta","zeroDelta","minErrorDelta","minTolerance","rho","undefined","chi","psi","sigma","N","simplex","fx","id","point","slice","updateSimplex","sortOrder","centroid","reflected","contracted","expanded","iteration","sort","history","sortedSimplex","state","push","max","abs","worst","shouldReduce","wolfeLineSearch","pk","current","next","c1","c2","phi0","phiPrime0","fxprime","phi","phi_old","phiPrime","a0","zoom","a_lo","a_high","phi_lo","conjugateGradient","initial","params","temp","yk","alpha","delta_k","SMALL","intersectionArea","circles","stats","intersectionPoints","intersect","circleCircleIntersection","k","p","parentIndex","getIntersectionPoints","innerPoints","filter","distance","radius","containedInCircles","arcArea","polygonArea","arcs","center","getCenter","angle","atan2","p2","p1","midPoint","arc","indexOf","circle","a1","a2","angleDiff","PI","sin","cos","circleArea","smallest","disjoint","area","acos","circleOverlap","r1","r2","d","min","h","y0","rx","ry","points","venn","areas","initialLayout","bestInitialLayout","loss","lossFunction","ids","pairs","sets","addMissingAreas","setid","setids","hasOwnProperty","solution","values","totalFunctionCalls","positions","distanceFromIntersectArea","overlap","tolerance","fA","fB","delta","mid","fMid","bisect","set","setOverlaps","rowid","size","weight","left","right","mostOverlapped","positioned","isPositioned","element","positionSet","index","setIndex","d1","d2","extraPoints","l","bestLoss","bestPoint","localLoss","greedyLayout","constrained","restarts","matrices","distances","constraints","getDistanceMatrices","norm","row","best","obj","xi","yi","xj","yj","dij","constraint","squaredDistance","constrainedMDSGradient","random","constrainedMDSLayout","overlaps","output","orientateCircles","orientation","orientationOrder","largestX","largestY","rotation","s","slope","getBoundingBox","minMax","apply","xRange","yRange","normalizeSolution","previous","clusters","find","parent","union","xRoot","yRoot","maxDistance","disjointClusters","disjointCluster","bounds","returnBounds","spacing","addCluster","cluster","bottom","xOffset","yOffset","centreing","scaleSolution","padding","console","log","xScaling","yScaling","scaling","scaled","circleMargin","interior","exterior","m","margin","computeTextCentre","valid","areaStats","getOverlappingCircles","circleids","circleid","computeTextCentres","overlapped","areaids","exclude","centre","intersectionAreaPath","join","circlePath","wide","Venn","Series","constructor","Object","defineProperty","children","Container","slicesContainer","Graphics","position","isMeasured","addDisposer","_makeSlices","_makeLabels","_afterNew","_defaultThemes","fields","makeSlice","dataItem","slices","make","events","on","e","_hovered","target","_updateHover","hoverGraphics","hide","updateLegendMarker","_setDataItem","get","show","toFront","makeLabel","label","labelsContainer","labels","ListTemplate","Template","_new","themeTags","$utils","template","Label","processDataItem","setRaw","patterns","_prepareChildren","_valuesDirty","_sizeDirty","$array","dataItems","intersections","visible","setPrivate","newSets","toString","_sets","vennData","innerWidth","innerHeight","name","item","getDataItemByCategory","color","_setDefault","fillPattern","centers","cc","intersectionPath","svgPath","updateLegendValue","showDataItem","duration","promises","_super","call","$type","easing","animation","animate","key","to","waitForStop","cat","di","isHidden","category","allVisible","dii","Promise","all","hideDataItem","hiddenState","states","create","hideTooltip","disposeDataItem","removeValue","dispose","legendDataItem","markerRectangle","visualSettings","setting","hoverDataItem","hover","unhoverDataItem","unhover","classNames","concat","className"],"mappings":"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","file":"static/js/18.0625b1e4.chunk.js","sourcesContent":["import { Theme } from \"../../core/Theme\";\r\nimport { p50, p100 } from \"../../core/util/Percent\";\r\nimport { ColorSet } from \"../../core/util/ColorSet\";\r\n\r\n\r\n/**\r\n * @ignore\r\n */\r\nexport class VennDefaultTheme extends Theme {\r\n\tprotected setupDefaultRules() {\r\n\t\tsuper.setupDefaultRules();\r\n\t\tconst r = this.rule.bind(this);\r\n\r\n\t\tr(\"Venn\").setAll({\r\n\t\t\tlegendLabelText: \"{category}\",\r\n\t\t\tlegendValueText: \"{value}\",\r\n\t\t\tcolors: ColorSet.new(this._root, {}),\r\n\t\t\twidth: p100,\r\n\t\t\theight: p100\r\n\t\t});\r\n\r\n\r\n\t\tr(\"Label\", [\"venn\"]).setAll({\r\n\t\t\ttext: \"{category}\",\r\n\t\t\tpopulateText: true,\r\n\t\t\tcenterX: p50,\r\n\t\t\tcenterY: p50\r\n\t\t});\r\n\r\n\t}\r\n}\r\n","// need some basic operations on vectors, rather than adding a dependency,\n// just define here\nexport function zeros(x) { var r = new Array(x); for (var i = 0; i < x; ++i) { r[i] = 0; } return r; }\nexport function zerosM(x,y) { return zeros(x).map(function() { return zeros(y); }); }\n\nexport function dot(a, b) {\n    var ret = 0;\n    for (var i = 0; i < a.length; ++i) {\n        ret += a[i] * b[i];\n    }\n    return ret;\n}\n\nexport function norm2(a)  {\n    return Math.sqrt(dot(a, a));\n}\n\nexport function scale(ret, value, c) {\n    for (var i = 0; i < value.length; ++i) {\n        ret[i] = value[i] * c;\n    }\n}\n\nexport function weightedSum(ret, w1, v1, w2, v2) {\n    for (var j = 0; j < ret.length; ++j) {\n        ret[j] = w1 * v1[j] + w2 * v2[j];\n    }\n}\n","import {dot, norm2, weightedSum} from \"./blas1\";\n\n/** minimizes a function using the downhill simplex method */\nexport function nelderMead(f, x0, parameters) {\n    parameters = parameters || {};\n\n    var maxIterations = parameters.maxIterations || x0.length * 200,\n        nonZeroDelta = parameters.nonZeroDelta || 1.05,\n        zeroDelta = parameters.zeroDelta || 0.001,\n        minErrorDelta = parameters.minErrorDelta || 1e-6,\n        minTolerance = parameters.minErrorDelta || 1e-5,\n        rho = (parameters.rho !== undefined) ? parameters.rho : 1,\n        chi = (parameters.chi !== undefined) ? parameters.chi : 2,\n        psi = (parameters.psi !== undefined) ? parameters.psi : -0.5,\n        sigma = (parameters.sigma !== undefined) ? parameters.sigma : 0.5,\n        maxDiff;\n\n    // initialize simplex.\n    var N = x0.length,\n        simplex = new Array(N + 1);\n    simplex[0] = x0;\n    simplex[0].fx = f(x0);\n    simplex[0].id = 0;\n    for (var i = 0; i < N; ++i) {\n        var point = x0.slice();\n        point[i] = point[i] ? point[i] * nonZeroDelta : zeroDelta;\n        simplex[i+1] = point;\n        simplex[i+1].fx = f(point);\n        simplex[i+1].id = i+1;\n    }\n\n    function updateSimplex(value) {\n        for (var i = 0; i < value.length; i++) {\n            simplex[N][i] = value[i];\n        }\n        simplex[N].fx = value.fx;\n    }\n\n    var sortOrder = function(a, b) { return a.fx - b.fx; };\n\n    var centroid = x0.slice(),\n        reflected = x0.slice(),\n        contracted = x0.slice(),\n        expanded = x0.slice();\n\n    for (var iteration = 0; iteration < maxIterations; ++iteration) {\n        simplex.sort(sortOrder);\n\n        if (parameters.history) {\n            // copy the simplex (since later iterations will mutate) and\n            // sort it to have a consistent order between iterations\n            var sortedSimplex = simplex.map(function (x) {\n                var state = x.slice();\n                state.fx = x.fx;\n                state.id = x.id;\n                return state;\n            });\n            sortedSimplex.sort(function(a,b) { return a.id - b.id; });\n\n            parameters.history.push({x: simplex[0].slice(),\n                                     fx: simplex[0].fx,\n                                     simplex: sortedSimplex});\n        }\n\n        maxDiff = 0;\n        for (i = 0; i < N; ++i) {\n            maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));\n        }\n\n        if ((Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta) &&\n            (maxDiff < minTolerance)) {\n            break;\n        }\n\n        // compute the centroid of all but the worst point in the simplex\n        for (i = 0; i < N; ++i) {\n            centroid[i] = 0;\n            for (var j = 0; j < N; ++j) {\n                centroid[i] += simplex[j][i];\n            }\n            centroid[i] /= N;\n        }\n\n        // reflect the worst point past the centroid  and compute loss at reflected\n        // point\n        var worst = simplex[N];\n        weightedSum(reflected, 1+rho, centroid, -rho, worst);\n        reflected.fx = f(reflected);\n\n        // if the reflected point is the best seen, then possibly expand\n        if (reflected.fx < simplex[0].fx) {\n            weightedSum(expanded, 1+chi, centroid, -chi, worst);\n            expanded.fx = f(expanded);\n            if (expanded.fx < reflected.fx) {\n                updateSimplex(expanded);\n            }  else {\n                updateSimplex(reflected);\n            }\n        }\n\n        // if the reflected point is worse than the second worst, we need to\n        // contract\n        else if (reflected.fx >= simplex[N-1].fx) {\n            var shouldReduce = false;\n\n            if (reflected.fx > worst.fx) {\n                // do an inside contraction\n                weightedSum(contracted, 1+psi, centroid, -psi, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < worst.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            } else {\n                // do an outside contraction\n                weightedSum(contracted, 1-psi * rho, centroid, psi*rho, worst);\n                contracted.fx = f(contracted);\n                if (contracted.fx < reflected.fx) {\n                    updateSimplex(contracted);\n                } else {\n                    shouldReduce = true;\n                }\n            }\n\n            if (shouldReduce) {\n                // if we don't contract here, we're done\n                if (sigma >= 1) break;\n\n                // do a reduction\n                for (i = 1; i < simplex.length; ++i) {\n                    weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);\n                    simplex[i].fx = f(simplex[i]);\n                }\n            }\n        } else {\n            updateSimplex(reflected);\n        }\n    }\n\n    simplex.sort(sortOrder);\n    return {fx : simplex[0].fx,\n            x : simplex[0]};\n}\n","import {dot, weightedSum} from \"./blas1\";\n\n\n/// searches along line 'pk' for a point that satifies the wolfe conditions\n/// See 'Numerical Optimization' by Nocedal and Wright p59-60\n/// f : objective function\n/// pk : search direction\n/// current: object containing current gradient/loss\n/// next: output: contains next gradient/loss\n/// returns a: step size taken\nexport function wolfeLineSearch(f, pk, current, next, a, c1, c2) {\n    var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk),\n        phi = phi0, phi_old = phi0,\n        phiPrime = phiPrime0,\n        a0 = 0;\n\n    a = a || 1;\n    c1 = c1 || 1e-6;\n    c2 = c2 || 0.1;\n\n    function zoom(a_lo, a_high, phi_lo) {\n        for (var iteration = 0; iteration < 16; ++iteration) {\n            a = (a_lo + a_high)/2;\n            weightedSum(next.x, 1.0, current.x, a, pk);\n            phi = next.fx = f(next.x, next.fxprime);\n            phiPrime = dot(next.fxprime, pk);\n\n            if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n                (phi >= phi_lo)) {\n                a_high = a;\n\n            } else  {\n                if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n                    return a;\n                }\n\n                if (phiPrime * (a_high - a_lo) >=0) {\n                    a_high = a_lo;\n                }\n\n                a_lo = a;\n                phi_lo = phi;\n            }\n        }\n\n        return 0;\n    }\n\n    for (var iteration = 0; iteration < 10; ++iteration) {\n        weightedSum(next.x, 1.0, current.x, a, pk);\n        phi = next.fx = f(next.x, next.fxprime);\n        phiPrime = dot(next.fxprime, pk);\n        if ((phi > (phi0 + c1 * a * phiPrime0)) ||\n            (iteration && (phi >= phi_old))) {\n            return zoom(a0, a, phi_old);\n        }\n\n        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {\n            return a;\n        }\n\n        if (phiPrime >= 0 ) {\n            return zoom(a, a0, phi);\n        }\n\n        phi_old = phi;\n        a0 = a;\n        a *= 2;\n    }\n\n    return a;\n}\n","import {dot, norm2, scale, weightedSum} from \"./blas1\";\nimport {wolfeLineSearch} from \"./linesearch\";\n\nexport function conjugateGradient(f, initial, params) {\n    // allocate all memory up front here, keep out of the loop for perfomance\n    // reasons\n    var current = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n        next = {x: initial.slice(), fx: 0, fxprime: initial.slice()},\n        yk = initial.slice(),\n        pk, temp,\n        a = 1,\n        maxIterations;\n\n    params = params || {};\n    maxIterations = params.maxIterations || initial.length * 20;\n\n    current.fx = f(current.x, current.fxprime);\n    pk = current.fxprime.slice();\n    scale(pk, current.fxprime,-1);\n\n    for (var i = 0; i < maxIterations; ++i) {\n        a = wolfeLineSearch(f, pk, current, next, a);\n\n        // todo: history in wrong spot?\n        if (params.history) {\n            params.history.push({x: current.x.slice(),\n                                 fx: current.fx,\n                                 fxprime: current.fxprime.slice(),\n                                 alpha: a});\n        }\n\n        if (!a) {\n            // faiiled to find point that satifies wolfe conditions.\n            // reset direction for next iteration\n            scale(pk, current.fxprime, -1);\n\n        } else {\n            // update direction using Polak–Ribiere CG method\n            weightedSum(yk, 1, next.fxprime, -1, current.fxprime);\n\n            var delta_k = dot(current.fxprime, current.fxprime),\n                beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);\n\n            weightedSum(pk, beta_k, pk, -1, next.fxprime);\n\n            temp = current;\n            current = next;\n            next = temp;\n        }\n\n        if (norm2(current.fxprime) <= 1e-5) {\n            break;\n        }\n    }\n\n    if (params.history) {\n        params.history.push({x: current.x.slice(),\n                             fx: current.fx,\n                             fxprime: current.fxprime.slice(),\n                             alpha: a});\n    }\n\n    return current;\n}\n","var SMALL = 1e-10;\n\n/** Returns the intersection area of a bunch of circles (where each circle\n is an object having an x,y and radius property) */\nexport function intersectionArea(circles, stats) {\n    // get all the intersection points of the circles\n    var intersectionPoints = getIntersectionPoints(circles);\n\n    // filter out points that aren't included in all the circles\n    var innerPoints = intersectionPoints.filter(function (p) {\n        return containedInCircles(p, circles);\n    });\n\n    var arcArea = 0, polygonArea = 0, arcs = [], i;\n\n    // if we have intersection points that are within all the circles,\n    // then figure out the area contained by them\n    if (innerPoints.length > 1) {\n        // sort the points by angle from the center of the polygon, which lets\n        // us just iterate over points to get the edges\n        var center = getCenter(innerPoints);\n        for (i = 0; i < innerPoints.length; ++i ) {\n            var p = innerPoints[i];\n            p.angle = Math.atan2(p.x - center.x, p.y - center.y);\n        }\n        innerPoints.sort(function(a,b) { return b.angle - a.angle;});\n\n        // iterate over all points, get arc between the points\n        // and update the areas\n        var p2 = innerPoints[innerPoints.length - 1];\n        for (i = 0; i < innerPoints.length; ++i) {\n            var p1 = innerPoints[i];\n\n            // polygon area updates easily ...\n            polygonArea += (p2.x + p1.x) * (p1.y - p2.y);\n\n            // updating the arc area is a little more involved\n            var midPoint = {x : (p1.x + p2.x) / 2,\n                            y : (p1.y + p2.y) / 2},\n                arc = null;\n\n            for (var j = 0; j < p1.parentIndex.length; ++j) {\n                if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {\n                    // figure out the angle halfway between the two points\n                    // on the current circle\n                    var circle = circles[p1.parentIndex[j]],\n                        a1 = Math.atan2(p1.x - circle.x, p1.y - circle.y),\n                        a2 = Math.atan2(p2.x - circle.x, p2.y - circle.y);\n\n                    var angleDiff = (a2 - a1);\n                    if (angleDiff < 0) {\n                        angleDiff += 2*Math.PI;\n                    }\n\n                    // and use that angle to figure out the width of the\n                    // arc\n                    var a = a2 - angleDiff/2,\n                        width = distance(midPoint, {\n                            x : circle.x + circle.radius * Math.sin(a),\n                            y : circle.y + circle.radius * Math.cos(a)\n                        });\n\n                    // clamp the width to the largest is can actually be\n                    // (sometimes slightly overflows because of FP errors)\n                    if (width > circle.radius * 2) {\n                        width = circle.radius * 2;\n                    }\n\n                    // pick the circle whose arc has the smallest width\n                    if ((arc === null) || (arc.width > width)) {\n                        arc = { circle : circle,\n                                width : width,\n                                p1 : p1,\n                                p2 : p2};\n                    }\n                }\n            }\n\n            if (arc !== null) {\n                arcs.push(arc);\n                arcArea += circleArea(arc.circle.radius, arc.width);\n                p2 = p1;\n            }\n        }\n    } else {\n        // no intersection points, is either disjoint - or is completely\n        // overlapped. figure out which by examining the smallest circle\n        var smallest = circles[0];\n        for (i = 1; i < circles.length; ++i) {\n            if (circles[i].radius < smallest.radius) {\n                smallest = circles[i];\n            }\n        }\n\n        // make sure the smallest circle is completely contained in all\n        // the other circles\n        var disjoint = false;\n        for (i = 0; i < circles.length; ++i) {\n            if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {\n                disjoint = true;\n                break;\n            }\n        }\n\n        if (disjoint) {\n            arcArea = polygonArea = 0;\n\n        } else {\n            arcArea = smallest.radius * smallest.radius * Math.PI;\n            arcs.push({circle : smallest,\n                       p1: { x: smallest.x,        y : smallest.y + smallest.radius},\n                       p2: { x: smallest.x - SMALL, y : smallest.y + smallest.radius},\n                       width : smallest.radius * 2 });\n        }\n    }\n\n    polygonArea /= 2;\n    if (stats) {\n        stats.area = arcArea + polygonArea;\n        stats.arcArea = arcArea;\n        stats.polygonArea = polygonArea;\n        stats.arcs = arcs;\n        stats.innerPoints = innerPoints;\n        stats.intersectionPoints = intersectionPoints;\n    }\n\n    return arcArea + polygonArea;\n}\n\n/** returns whether a point is contained by all of a list of circles */\nexport function containedInCircles(point, circles) {\n    for (var i = 0; i < circles.length; ++i) {\n        if (distance(point, circles[i]) > circles[i].radius + SMALL) {\n            return false;\n        }\n    }\n    return true;\n}\n\n/** Gets all intersection points between a bunch of circles */\nfunction getIntersectionPoints(circles) {\n    var ret = [];\n    for (var i = 0; i < circles.length; ++i) {\n        for (var j = i + 1; j < circles.length; ++j) {\n            var intersect = circleCircleIntersection(circles[i],\n                                                          circles[j]);\n            for (var k = 0; k < intersect.length; ++k) {\n                var p = intersect[k];\n                p.parentIndex = [i,j];\n                ret.push(p);\n            }\n        }\n    }\n    return ret;\n}\n\n/** Circular segment area calculation. See http://mathworld.wolfram.com/CircularSegment.html */\nexport function circleArea(r, width) {\n    return r * r * Math.acos(1 - width/r) - (r - width) * Math.sqrt(width * (2 * r - width));\n}\n\n/** euclidean distance between two points */\nexport function distance(p1, p2) {\n    return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) +\n                     (p1.y - p2.y) * (p1.y - p2.y));\n}\n\n\n/** Returns the overlap area of two circles of radius r1 and r2 - that\nhave their centers separated by distance d. Simpler faster\ncircle intersection for only two circles */\nexport function circleOverlap(r1, r2, d) {\n    // no overlap\n    if (d >= r1 + r2) {\n        return 0;\n    }\n\n    // completely overlapped\n    if (d <= Math.abs(r1 - r2)) {\n        return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);\n    }\n\n    var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d),\n        w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);\n    return circleArea(r1, w1) + circleArea(r2, w2);\n}\n\n/** Given two circles (containing a x/y/radius attributes),\nreturns the intersecting points if possible.\nnote: doesn't handle cases where there are infinitely many\nintersection points (circles are equivalent):, or only one intersection point*/\nexport function circleCircleIntersection(p1, p2) {\n    var d = distance(p1, p2),\n        r1 = p1.radius,\n        r2 = p2.radius;\n\n    // if to far away, or self contained - can't be done\n    if ((d >= (r1 + r2)) || (d <= Math.abs(r1 - r2))) {\n        return [];\n    }\n\n    var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d),\n        h = Math.sqrt(r1 * r1 - a * a),\n        x0 = p1.x + a * (p2.x - p1.x) / d,\n        y0 = p1.y + a * (p2.y - p1.y) / d,\n        rx = -(p2.y - p1.y) * (h / d),\n        ry = -(p2.x - p1.x) * (h / d);\n\n    return [{x: x0 + rx, y : y0 - ry },\n            {x: x0 - rx, y : y0 + ry }];\n}\n\n/** Returns the center of a bunch of points */\nexport function getCenter(points) {\n    var center = {x: 0, y: 0};\n    for (var i =0; i < points.length; ++i ) {\n        center.x += points[i].x;\n        center.y += points[i].y;\n    }\n    center.x /= points.length;\n    center.y /= points.length;\n    return center;\n}\n","import {nelderMead, bisect, conjugateGradient, zeros, zerosM, norm2,\n        scale} from './fmin/index.js';\nimport {intersectionArea, circleOverlap, circleCircleIntersection, distance} from './circleintersection';\n\n/** given a list of set objects, and their corresponding overlaps.\nupdates the (x, y, radius) attribute on each set such that their positions\nroughly correspond to the desired overlaps */\nexport function venn(areas, parameters) {\n    parameters = parameters || {};\n    parameters.maxIterations = parameters.maxIterations || 500;\n    var initialLayout = parameters.initialLayout || bestInitialLayout;\n    var loss = parameters.lossFunction || lossFunction;\n\n    // add in missing pairwise areas as having 0 size\n    areas = addMissingAreas(areas);\n\n    // initial layout is done greedily\n    var circles = initialLayout(areas, parameters);\n\n    // transform x/y coordinates to a vector to optimize\n    var initial = [], setids = [], setid;\n    for (setid in circles) {\n        if (circles.hasOwnProperty(setid)) {\n            initial.push(circles[setid].x);\n            initial.push(circles[setid].y);\n            setids.push(setid);\n        }\n    }\n\n    // optimize initial layout from our loss function\n    var totalFunctionCalls = 0;\n    var solution = nelderMead(\n        function(values) {\n            totalFunctionCalls += 1;\n            var current = {};\n            for (var i = 0; i < setids.length; ++i) {\n                var setid = setids[i];\n                current[setid] = {x: values[2 * i],\n                                  y: values[2 * i + 1],\n                                  radius : circles[setid].radius,\n                                 // size : circles[setid].size\n                                 };\n            }\n            return loss(current, areas);\n        },\n        initial,\n        parameters);\n\n    // transform solution vector back to x/y points\n    var positions = solution.x;\n    for (var i = 0; i < setids.length; ++i) {\n        setid = setids[i];\n        circles[setid].x = positions[2 * i];\n        circles[setid].y = positions[2 * i + 1];\n    }\n\n    return circles;\n}\n\nvar SMALL = 1e-10;\n\n/** Returns the distance necessary for two circles of radius r1 + r2 to\nhave the overlap area 'overlap' */\nexport function distanceFromIntersectArea(r1, r2, overlap) {\n    // handle complete overlapped circles\n    if (Math.min(r1, r2) * Math.min(r1,r2) * Math.PI <= overlap + SMALL) {\n        return Math.abs(r1 - r2);\n    }\n\n    return bisect(function(distance) {\n        return circleOverlap(r1, r2, distance) - overlap;\n    }, 0, r1 + r2);\n}\n\n/** Missing pair-wise intersection area data can cause problems:\n treating as an unknown means that sets will be laid out overlapping,\n which isn't what people expect. To reflect that we want disjoint sets\n here, set the overlap to 0 for all missing pairwise set intersections */\nfunction addMissingAreas(areas) {\n    areas = areas.slice();\n\n    // two circle intersections that aren't defined\n    var ids = [], pairs = {}, i, j, a, b;\n    for (i = 0; i < areas.length; ++i) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            ids.push(area.sets[0]);\n        } else if (area.sets.length == 2) {\n            a = area.sets[0];\n            b = area.sets[1];\n            pairs[[a, b]] = true;\n            pairs[[b, a]] = true;\n        }\n    }\n    ids.sort(function(a, b) { return a > b; });\n\n    for (i = 0; i < ids.length; ++i) {\n        a = ids[i];\n        for (j = i + 1; j < ids.length; ++j) {\n            b = ids[j];\n            if (!([a, b] in pairs)) {\n                areas.push({'sets': [a, b],\n                            'size': 0});\n            }\n        }\n    }\n    return areas;\n}\n\n/// Returns two matrices, one of the euclidean distances between the sets\n/// and the other indicating if there are subset or disjoint set relationships\nexport function getDistanceMatrices(areas, sets, setids) {\n    // initialize an empty distance matrix between all the points\n    var distances = zerosM(sets.length, sets.length),\n        constraints = zerosM(sets.length, sets.length);\n\n    // compute required distances between all the sets such that\n    // the areas match\n    areas.filter(function(x) { return x.sets.length == 2; })\n        .map(function(current) {\n        var left = setids[current.sets[0]],\n            right = setids[current.sets[1]],\n            r1 = Math.sqrt(sets[left].size / Math.PI),\n            r2 = Math.sqrt(sets[right].size / Math.PI),\n            distance = distanceFromIntersectArea(r1, r2, current.size);\n\n        distances[left][right] = distances[right][left] = distance;\n\n        // also update constraints to indicate if its a subset or disjoint\n        // relationship\n        var c = 0;\n        if (current.size + 1e-10 >= Math.min(sets[left].size,\n                                             sets[right].size)) {\n            c = 1;\n        } else if (current.size <= 1e-10) {\n            c = -1;\n        }\n        constraints[left][right] = constraints[right][left] = c;\n    });\n\n    return {distances: distances, constraints: constraints};\n}\n\n/// computes the gradient and loss simulatenously for our constrained MDS optimizer\nfunction constrainedMDSGradient(x, fxprime, distances, constraints) {\n    var loss = 0, i;\n    for (i = 0; i < fxprime.length; ++i) {\n        fxprime[i] = 0;\n    }\n\n    for (i = 0; i < distances.length; ++i) {\n        var xi = x[2 * i], yi = x[2 * i + 1];\n        for (var j = i + 1; j < distances.length; ++j) {\n            var xj = x[2 * j], yj = x[2 * j + 1],\n                dij = distances[i][j],\n                constraint = constraints[i][j];\n\n            var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi),\n                distance = Math.sqrt(squaredDistance),\n                delta = squaredDistance - dij * dij;\n\n            if (((constraint > 0) && (distance <= dij)) ||\n                ((constraint < 0) && (distance >= dij))) {\n                continue;\n            }\n\n            loss += 2 * delta * delta;\n\n            fxprime[2*i]     += 4 * delta * (xi - xj);\n            fxprime[2*i + 1] += 4 * delta * (yi - yj);\n\n            fxprime[2*j]     += 4 * delta * (xj - xi);\n            fxprime[2*j + 1] += 4 * delta * (yj - yi);\n        }\n    }\n    return loss;\n}\n\n/// takes the best working variant of either constrained MDS or greedy\nexport function bestInitialLayout(areas, params) {\n    var initial = greedyLayout(areas, params);\n    var loss = params.lossFunction || lossFunction;\n\n    // greedylayout is sufficient for all 2/3 circle cases. try out\n    // constrained MDS for higher order problems, take its output\n    // if it outperforms. (greedy is aesthetically better on 2/3 circles\n    // since it axis aligns)\n    if (areas.length >= 8) {\n        var constrained  = constrainedMDSLayout(areas, params),\n            constrainedLoss = loss(constrained, areas),\n            greedyLoss = loss(initial, areas);\n\n        if (constrainedLoss + 1e-8 < greedyLoss) {\n            initial = constrained;\n        }\n    }\n    return initial;\n}\n\n/// use the constrained MDS variant to generate an initial layout\nexport function constrainedMDSLayout(areas, params) {\n    params = params || {};\n    var restarts = params.restarts || 10;\n\n    // bidirectionally map sets to a rowid  (so we can create a matrix)\n    var sets = [], setids = {}, i;\n    for (i = 0; i < areas.length; ++i ) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            setids[area.sets[0]] = sets.length;\n            sets.push(area);\n        }\n    }\n\n    var matrices = getDistanceMatrices(areas, sets, setids),\n        distances = matrices.distances,\n        constraints = matrices.constraints;\n\n    // keep distances bounded, things get messed up otherwise.\n    // TODO: proper preconditioner?\n    var norm = norm2(distances.map(norm2))/(distances.length);\n    distances = distances.map(function (row) {\n        return row.map(function (value) { return value / norm; });});\n\n    var obj = function(x, fxprime) {\n        return constrainedMDSGradient(x, fxprime, distances, constraints);\n    };\n\n    var best, current;\n    for (i = 0; i < restarts; ++i) {\n        var initial = zeros(distances.length*2).map(Math.random);\n\n        current = conjugateGradient(obj, initial, params);\n        if (!best || (current.fx < best.fx)) {\n            best = current;\n        }\n    }\n    var positions = best.x;\n\n    // translate rows back to (x,y,radius) coordinates\n    var circles = {};\n    for (i = 0; i < sets.length; ++i) {\n        var set = sets[i];\n        circles[set.sets[0]] = {\n            x: positions[2*i] * norm,\n            y: positions[2*i + 1] * norm,\n            radius:  Math.sqrt(set.size / Math.PI)\n        };\n    }\n\n    if (params.history) {\n        for (i = 0; i < params.history.length; ++i) {\n            scale(params.history[i].x, norm);\n        }\n    }\n    return circles;\n}\n\n/** Lays out a Venn diagram greedily, going from most overlapped sets to\nleast overlapped, attempting to position each new set such that the\noverlapping areas to already positioned sets are basically right */\nexport function greedyLayout(areas, params) {\n    var loss = params && params.lossFunction ? params.lossFunction : lossFunction;\n    // define a circle for each set\n    var circles = {}, setOverlaps = {}, set;\n    for (var i = 0; i < areas.length; ++i) {\n        var area = areas[i];\n        if (area.sets.length == 1) {\n            set = area.sets[0];\n            circles[set] = {x: 1e10, y: 1e10,\n                            rowid: circles.length,\n                            size: area.size,\n                            radius: Math.sqrt(area.size / Math.PI)};\n            setOverlaps[set] = [];\n        }\n    }\n    areas = areas.filter(function(a) { return a.sets.length == 2; });\n\n    // map each set to a list of all the other sets that overlap it\n    for (i = 0; i < areas.length; ++i) {\n        var current = areas[i];\n        var weight = current.hasOwnProperty('weight') ? current.weight : 1.0;\n        var left = current.sets[0], right = current.sets[1];\n\n        // completely overlapped circles shouldn't be positioned early here\n        if (current.size + SMALL >= Math.min(circles[left].size,\n                                             circles[right].size)) {\n            weight = 0;\n        }\n\n        setOverlaps[left].push ({set:right, size:current.size, weight:weight});\n        setOverlaps[right].push({set:left,  size:current.size, weight:weight});\n    }\n\n    // get list of most overlapped sets\n    var mostOverlapped = [];\n    for (set in setOverlaps) {\n        if (setOverlaps.hasOwnProperty(set)) {\n            var size = 0;\n            for (i = 0; i < setOverlaps[set].length; ++i) {\n                size += setOverlaps[set][i].size * setOverlaps[set][i].weight;\n            }\n\n            mostOverlapped.push({set: set, size:size});\n        }\n    }\n\n    // sort by size desc\n    function sortOrder(a,b) {\n        return b.size - a.size;\n    }\n    mostOverlapped.sort(sortOrder);\n\n    // keep track of what sets have been laid out\n    var positioned = {};\n    function isPositioned(element) {\n        return element.set in positioned;\n    }\n\n    // adds a point to the output\n    function positionSet(point, index) {\n        circles[index].x = point.x;\n        circles[index].y = point.y;\n        positioned[index] = true;\n    }\n\n    // add most overlapped set at (0,0)\n    positionSet({x: 0, y: 0}, mostOverlapped[0].set);\n\n    // get distances between all points. TODO, necessary?\n    // answer: probably not\n    // var distances = venn.getDistanceMatrices(circles, areas).distances;\n    for (i = 1; i < mostOverlapped.length; ++i) {\n        var setIndex = mostOverlapped[i].set,\n            overlap = setOverlaps[setIndex].filter(isPositioned);\n        set = circles[setIndex];\n        overlap.sort(sortOrder);\n\n        if (overlap.length === 0) {\n            // this shouldn't happen anymore with addMissingAreas\n            throw \"ERROR: missing pairwise overlap information\";\n        }\n\n        var points = [];\n        for (var j = 0; j < overlap.length; ++j) {\n            // get appropriate distance from most overlapped already added set\n            var p1 = circles[overlap[j].set],\n                d1 = distanceFromIntersectArea(set.radius, p1.radius,\n                                               overlap[j].size);\n\n            // sample positions at 90 degrees for maximum aesthetics\n            points.push({x : p1.x + d1, y : p1.y});\n            points.push({x : p1.x - d1, y : p1.y});\n            points.push({y : p1.y + d1, x : p1.x});\n            points.push({y : p1.y - d1, x : p1.x});\n\n            // if we have at least 2 overlaps, then figure out where the\n            // set should be positioned analytically and try those too\n            for (var k = j + 1; k < overlap.length; ++k) {\n                var p2 = circles[overlap[k].set],\n                    d2 = distanceFromIntersectArea(set.radius, p2.radius,\n                                                   overlap[k].size);\n\n                var extraPoints = circleCircleIntersection(\n                    { x: p1.x, y: p1.y, radius: d1},\n                    { x: p2.x, y: p2.y, radius: d2});\n\n                for (var l = 0; l < extraPoints.length; ++l) {\n                    points.push(extraPoints[l]);\n                }\n            }\n        }\n\n        // we have some candidate positions for the set, examine loss\n        // at each position to figure out where to put it at\n        var bestLoss = 1e50, bestPoint = points[0];\n        for (j = 0; j < points.length; ++j) {\n            circles[setIndex].x = points[j].x;\n            circles[setIndex].y = points[j].y;\n            var localLoss = loss(circles, areas);\n            if (localLoss < bestLoss) {\n                bestLoss = localLoss;\n                bestPoint = points[j];\n            }\n        }\n\n        positionSet(bestPoint, setIndex);\n    }\n\n    return circles;\n}\n\n/** Given a bunch of sets, and the desired overlaps between these sets - computes\nthe distance from the actual overlaps to the desired overlaps. Note that\nthis method ignores overlaps of more than 2 circles */\nexport function lossFunction(sets, overlaps) {\n    var output = 0;\n\n    function getCircles(indices) {\n        return indices.map(function(i) { return sets[i]; });\n    }\n\n    for (var i = 0; i < overlaps.length; ++i) {\n        var area = overlaps[i], overlap;\n        if (area.sets.length == 1) {\n            continue;\n        } else if (area.sets.length == 2) {\n            var left = sets[area.sets[0]],\n                right = sets[area.sets[1]];\n            overlap = circleOverlap(left.radius, right.radius,\n                                    distance(left, right));\n        } else {\n            overlap = intersectionArea(getCircles(area.sets));\n        }\n\n        var weight = area.hasOwnProperty('weight') ? area.weight : 1.0;\n        output += weight * (overlap - area.size) * (overlap - area.size);\n    }\n\n    return output;\n}\n\n// orientates a bunch of circles to point in orientation\nfunction orientateCircles(circles, orientation, orientationOrder) {\n    if (orientationOrder === null) {\n        circles.sort(function (a, b) { return b.radius - a.radius; });\n    } else {\n        circles.sort(orientationOrder);\n    }\n\n    var i;\n    // shift circles so largest circle is at (0, 0)\n    if (circles.length > 0) {\n        var largestX = circles[0].x,\n            largestY = circles[0].y;\n\n        for (i = 0; i < circles.length; ++i) {\n            circles[i].x -= largestX;\n            circles[i].y -= largestY;\n        }\n    }\n\n    if (circles.length == 2) {\n        // if the second circle is a subset of the first, arrange so that\n        // it is off to one side. hack for https://github.com/benfred/venn.js/issues/120\n        var dist = distance(circles[0], circles[1]);\n        if (dist < Math.abs(circles[1].radius - circles[0].radius)) {\n            circles[1].x = circles[0].x + circles[0].radius - circles[1].radius - 1e-10;\n            circles[1].y = circles[0].y;\n        }\n    }\n\n    // rotate circles so that second largest is at an angle of 'orientation'\n    // from largest\n    if (circles.length > 1) {\n        var rotation = Math.atan2(circles[1].x, circles[1].y) - orientation,\n            c = Math.cos(rotation),\n            s = Math.sin(rotation), x, y;\n\n        for (i = 0; i < circles.length; ++i) {\n            x = circles[i].x;\n            y = circles[i].y;\n            circles[i].x = c * x - s * y;\n            circles[i].y = s * x + c * y;\n        }\n    }\n\n    // mirror solution if third solution is above plane specified by\n    // first two circles\n    if (circles.length > 2) {\n        var angle = Math.atan2(circles[2].x, circles[2].y) - orientation;\n        while (angle < 0) { angle += 2* Math.PI; }\n        while (angle > 2*Math.PI) { angle -= 2* Math.PI; }\n        if (angle > Math.PI) {\n            var slope = circles[1].y / (1e-10 + circles[1].x);\n            for (i = 0; i < circles.length; ++i) {\n                var d = (circles[i].x + slope * circles[i].y) / (1 + slope*slope);\n                circles[i].x = 2 * d - circles[i].x;\n                circles[i].y = 2 * d * slope - circles[i].y;\n            }\n        }\n    }\n}\n\nexport function disjointCluster(circles) {\n    // union-find clustering to get disjoint sets\n    circles.map(function(circle) { circle.parent = circle; });\n\n    // path compression step in union find\n    function find(circle) {\n        if (circle.parent !== circle) {\n            circle.parent = find(circle.parent);\n        }\n        return circle.parent;\n    }\n\n    function union(x, y) {\n        var xRoot = find(x), yRoot = find(y);\n        xRoot.parent = yRoot;\n    }\n\n    // get the union of all overlapping sets\n    for (var i = 0; i < circles.length; ++i) {\n        for (var j = i + 1; j < circles.length; ++j) {\n            var maxDistance = circles[i].radius + circles[j].radius;\n            if (distance(circles[i], circles[j]) + 1e-10 < maxDistance) {\n                union(circles[j], circles[i]);\n            }\n        }\n    }\n\n    // find all the disjoint clusters and group them together\n    var disjointClusters = {}, setid;\n    for (i = 0; i < circles.length; ++i) {\n        setid = find(circles[i]).parent.setid;\n        if (!(setid in disjointClusters)) {\n            disjointClusters[setid] = [];\n        }\n        disjointClusters[setid].push(circles[i]);\n    }\n\n    // cleanup bookkeeping\n    circles.map(function(circle) { delete circle.parent; });\n\n    // return in more usable form\n    var ret = [];\n    for (setid in disjointClusters) {\n        if (disjointClusters.hasOwnProperty(setid)) {\n            ret.push(disjointClusters[setid]);\n        }\n    }\n    return ret;\n}\n\nfunction getBoundingBox(circles) {\n    var minMax = function(d) {\n        var hi = Math.max.apply(null, circles.map(\n                                function(c) { return c[d] + c.radius; } )),\n            lo = Math.min.apply(null, circles.map(\n                                function(c) { return c[d] - c.radius;} ));\n        return {max:hi, min:lo};\n    };\n\n    return {xRange: minMax('x'), yRange: minMax('y')};\n}\n\nexport function normalizeSolution(solution, orientation, orientationOrder) {\n    if (orientation === null){\n        orientation = Math.PI/2;\n    }\n\n    // work with a list instead of a dictionary, and take a copy so we\n    // don't mutate input\n    var circles = [], i, setid;\n    for (setid in solution) {\n        if (solution.hasOwnProperty(setid)) {\n            var previous = solution[setid];\n            circles.push({x: previous.x,\n                          y: previous.y,\n                          radius: previous.radius,\n                          setid: setid});\n        }\n    }\n\n    // get all the disjoint clusters\n    var clusters = disjointCluster(circles);\n\n    // orientate all disjoint sets, get sizes\n    for (i = 0; i < clusters.length; ++i) {\n        orientateCircles(clusters[i], orientation, orientationOrder);\n        var bounds = getBoundingBox(clusters[i]);\n        clusters[i].size = (bounds.xRange.max - bounds.xRange.min) * (bounds.yRange.max - bounds.yRange.min);\n        clusters[i].bounds = bounds;\n    }\n    clusters.sort(function(a, b) { return b.size - a.size; });\n\n    // orientate the largest at 0,0, and get the bounds\n    circles = clusters[0];\n    var returnBounds = circles.bounds;\n\n    var spacing = (returnBounds.xRange.max - returnBounds.xRange.min)/50;\n\n    function addCluster(cluster, right, bottom) {\n        if (!cluster) return;\n\n        var bounds = cluster.bounds, xOffset, yOffset, centreing;\n\n        if (right) {\n            xOffset = returnBounds.xRange.max  - bounds.xRange.min + spacing;\n        } else {\n            xOffset = returnBounds.xRange.max  - bounds.xRange.max;\n            centreing = (bounds.xRange.max - bounds.xRange.min) / 2 -\n                        (returnBounds.xRange.max - returnBounds.xRange.min) / 2;\n            if (centreing < 0) xOffset += centreing;\n        }\n\n        if (bottom) {\n            yOffset = returnBounds.yRange.max  - bounds.yRange.min + spacing;\n        } else {\n            yOffset = returnBounds.yRange.max  - bounds.yRange.max;\n            centreing = (bounds.yRange.max - bounds.yRange.min) / 2 -\n                        (returnBounds.yRange.max - returnBounds.yRange.min) / 2;\n            if (centreing < 0) yOffset += centreing;\n        }\n\n        for (var j = 0; j < cluster.length; ++j) {\n            cluster[j].x += xOffset;\n            cluster[j].y += yOffset;\n            circles.push(cluster[j]);\n        }\n    }\n\n    var index = 1;\n    while (index < clusters.length) {\n        addCluster(clusters[index], true, false);\n        addCluster(clusters[index+1], false, true);\n        addCluster(clusters[index+2], true, true);\n        index += 3;\n\n        // have one cluster (in top left). lay out next three relative\n        // to it in a grid\n        returnBounds = getBoundingBox(circles);\n    }\n\n    // convert back to solution form\n    var ret = {};\n    for (i = 0; i < circles.length; ++i) {\n        ret[circles[i].setid] = circles[i];\n    }\n    return ret;\n}\n\n/** Scales a solution from venn.venn or venn.greedyLayout such that it fits in\na rectangle of width/height - with padding around the borders. also\ncenters the diagram in the available space at the same time */\nexport function scaleSolution(solution, width, height, padding) {\n    var circles = [], setids = [];\n    for (var setid in solution) {\n        if (solution.hasOwnProperty(setid)) {\n            setids.push(setid);\n            circles.push(solution[setid]);\n        }\n    }\n\n    width -= 2*padding;\n    height -= 2*padding;\n\n    var bounds = getBoundingBox(circles),\n        xRange = bounds.xRange,\n        yRange = bounds.yRange;\n\n    if ((xRange.max == xRange.min) ||\n        (yRange.max == yRange.min)) {\n        console.log(\"not scaling solution: zero size detected\");\n        return solution;\n    }\n\n    var xScaling = width  / (xRange.max - xRange.min),\n        yScaling = height / (yRange.max - yRange.min),\n        scaling = Math.min(yScaling, xScaling),\n\n        // while we're at it, center the diagram too\n        xOffset = (width -  (xRange.max - xRange.min) * scaling) / 2,\n        yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;\n\n    var scaled = {};\n    for (var i = 0; i < circles.length; ++i) {\n        var circle = circles[i];\n        scaled[setids[i]] = {\n            radius: scaling * circle.radius,\n            x: padding + xOffset + (circle.x - xRange.min) * scaling,\n            y: padding + yOffset + (circle.y - yRange.min) * scaling,\n        };\n    }\n\n    return scaled;\n}\n","/** finds the zeros of a function, given two starting points (which must\n * have opposite signs */\nexport function bisect(f, a, b, parameters) {\n    parameters = parameters || {};\n    var maxIterations = parameters.maxIterations || 100,\n        tolerance = parameters.tolerance || 1e-10,\n        fA = f(a),\n        fB = f(b),\n        delta = b - a;\n\n    if (fA * fB > 0) {\n        throw \"Initial bisect points must have opposite signs\";\n    }\n\n    if (fA === 0) return a;\n    if (fB === 0) return b;\n\n    for (var i = 0; i < maxIterations; ++i) {\n        delta /= 2;\n        var mid = a + delta,\n            fMid = f(mid);\n\n        if (fMid * fA >= 0) {\n            a = mid;\n        }\n\n        if ((Math.abs(delta) < tolerance) || (fMid === 0)) {\n            return mid;\n        }\n    }\n    return a + delta;\n}\n","import {select, selectAll} from \"d3-selection\";\nimport {transition} from \"d3-transition\";\n\nimport {venn, lossFunction, normalizeSolution, scaleSolution} from \"./layout\";\nimport {intersectionArea, distance, getCenter} from \"./circleintersection\";\nimport {nelderMead} from \"./fmin/index.js\";\n\n/*global console:true*/\n\nexport function VennDiagram() {\n    var width = 600,\n        height = 350,\n        padding = 15,\n        duration = 1000,\n        orientation = Math.PI / 2,\n        normalize = true,\n        wrap = true,\n        styled = true,\n        fontSize = null,\n        orientationOrder = null,\n\n        // mimic the behaviour of d3.scale.category10 from the previous\n        // version of d3\n        colourMap = {},\n\n        // so this is the same as d3.schemeCategory10, which is only defined in d3 4.0\n        // since we can support older versions of d3 as long as we don't force this,\n        // I'm hackily redefining below. TODO: remove this and change to d3.schemeCategory10\n        colourScheme = [\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\", \"#d62728\", \"#9467bd\", \"#8c564b\", \"#e377c2\", \"#7f7f7f\", \"#bcbd22\", \"#17becf\"],\n        colourIndex = 0,\n        colours = function(key) {\n            if (key in colourMap) {\n                return colourMap[key];\n            }\n            var ret = colourMap[key] = colourScheme[colourIndex];\n            colourIndex += 1;\n            if (colourIndex >= colourScheme.length) {\n                colourIndex = 0;\n            }\n            return ret;\n        },\n        layoutFunction = venn,\n        loss = lossFunction;\n\n\n    function chart(selection) {\n        var data = selection.datum();\n\n        // handle 0-sized sets by removing from input\n        var toremove = {};\n        data.forEach(function(datum) {\n            if ((datum.size == 0) && datum.sets.length == 1) {\n                toremove[datum.sets[0]] = 1;\n            }\n        });\n        data = data.filter(function(datum) {\n            return !datum.sets.some(function(set) { return set in toremove; });\n        });\n\n        var circles = {};\n        var textCentres = {};\n\n        if (data.length > 0) {\n            var solution = layoutFunction(data, {lossFunction: loss});\n\n            if (normalize) {\n                solution = normalizeSolution(solution,\n                                            orientation,\n                                            orientationOrder);\n            }\n\n            circles = scaleSolution(solution, width, height, padding);\n            textCentres = computeTextCentres(circles, data);\n        }\n\n        // Figure out the current label for each set. These can change\n        // and D3 won't necessarily update (fixes https://github.com/benfred/venn.js/issues/103)\n        var labels = {};\n        data.forEach(function(datum) {\n            if (datum.label) {\n                labels[datum.sets] = datum.label;\n            }\n        });\n\n        function label(d) {\n            if (d.sets in labels) {\n                return labels[d.sets];\n            }\n            if (d.sets.length == 1) {\n                return '' + d.sets[0];\n            }\n        }\n\n        // create svg if not already existing\n        selection.selectAll(\"svg\").data([circles]).enter().append(\"svg\");\n\n        var svg = selection.select(\"svg\")\n            .attr(\"width\", width)\n            .attr(\"height\", height);\n\n        // to properly transition intersection areas, we need the\n        // previous circles locations. load from elements\n        var previous = {}, hasPrevious = false;\n        svg.selectAll(\".venn-area path\").each(function (d) {\n            var path = select(this).attr(\"d\");\n            if ((d.sets.length == 1) && path) {\n                hasPrevious = true;\n                previous[d.sets[0]] = circleFromPath(path);\n            }\n        });\n\n        // interpolate intersection area paths between previous and\n        // current paths\n        var pathTween = function(d) {\n            return function(t) {\n                var c = d.sets.map(function(set) {\n                    var start = previous[set], end = circles[set];\n                    if (!start) {\n                        start = {x : width/2, y : height/2, radius : 1};\n                    }\n                    if (!end) {\n                        end = {x : width/2, y : height/2, radius : 1};\n                    }\n                    return {'x' : start.x * (1 - t) + end.x * t,\n                            'y' : start.y * (1 - t) + end.y * t,\n                            'radius' : start.radius * (1 - t) + end.radius * t};\n                });\n                return intersectionAreaPath(c);\n            };\n        };\n\n        // update data, joining on the set ids\n        var nodes = svg.selectAll(\".venn-area\")\n            .data(data, function(d) { return d.sets; });\n\n        // create new nodes\n        var enter = nodes.enter()\n            .append('g')\n            .attr(\"class\", function(d) {\n                return \"venn-area venn-\" +\n                    (d.sets.length == 1 ? \"circle\" : \"intersection\");\n            })\n            .attr(\"data-venn-sets\", function(d) {\n                return d.sets.join(\"_\");\n            });\n\n        var enterPath = enter.append(\"path\"),\n            enterText = enter.append(\"text\")\n            .attr(\"class\", \"label\")\n            .text(function (d) { return label(d); } )\n            .attr(\"text-anchor\", \"middle\")\n            .attr(\"dy\", \".35em\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height/2);\n\n\n        // apply minimal style if wanted\n        if (styled) {\n            enterPath.style(\"fill-opacity\", \"0\")\n                .filter(function (d) { return d.sets.length == 1; } )\n                .style(\"fill\", function(d) { return colours(d.sets); })\n                .style(\"fill-opacity\", \".25\");\n\n            enterText\n                .style(\"fill\", function(d) { return d.sets.length == 1 ? colours(d.sets) : \"#444\"; });\n        }\n\n        // update existing, using pathTween if necessary\n        var update = selection;\n        if (hasPrevious) {\n            update = selection.transition(\"venn\").duration(duration);\n            update.selectAll(\"path\")\n                .attrTween(\"d\", pathTween);\n        } else {\n            update.selectAll(\"path\")\n                .attr(\"d\", function(d) {\n                    return intersectionAreaPath(d.sets.map(function (set) { return circles[set]; }));\n                });\n        }\n\n        var updateText = update.selectAll(\"text\")\n            .filter(function (d) { return d.sets in textCentres; })\n            .text(function (d) { return label(d); } )\n            .attr(\"x\", function(d) { return Math.floor(textCentres[d.sets].x);})\n            .attr(\"y\", function(d) { return Math.floor(textCentres[d.sets].y);});\n\n        if (wrap) {\n            if (hasPrevious) {\n                // d3 4.0 uses 'on' for events on transitions,\n                // but d3 3.0 used 'each' instead. switch appropiately\n                if ('on' in updateText) {\n                    updateText.on(\"end\", wrapText(circles, label));\n                } else {\n                    updateText.each(\"end\", wrapText(circles, label));\n                }\n            } else {\n                updateText.each(wrapText(circles, label));\n            }\n        }\n\n        // remove old\n        var exit = nodes.exit().transition('venn').duration(duration).remove();\n        exit.selectAll(\"path\")\n            .attrTween(\"d\", pathTween);\n\n        var exitText = exit.selectAll(\"text\")\n            .attr(\"x\", width/2)\n            .attr(\"y\", height/2);\n\n        // if we've been passed a fontSize explicitly, use it to\n        // transition\n        if (fontSize !== null) {\n            enterText.style(\"font-size\", \"0px\");\n            updateText.style(\"font-size\", fontSize);\n            exitText.style(\"font-size\", \"0px\");\n        }\n\n\n        return {'circles': circles,\n                'textCentres': textCentres,\n                'nodes': nodes,\n                'enter': enter,\n                'update': update,\n                'exit': exit};\n    }\n\n    chart.wrap = function(_) {\n        if (!arguments.length) return wrap;\n        wrap = _;\n        return chart;\n    };\n\n    chart.width = function(_) {\n        if (!arguments.length) return width;\n        width = _;\n        return chart;\n    };\n\n    chart.height = function(_) {\n        if (!arguments.length) return height;\n        height = _;\n        return chart;\n    };\n\n    chart.padding = function(_) {\n        if (!arguments.length) return padding;\n        padding = _;\n        return chart;\n    };\n\n    chart.colours = function(_) {\n        if (!arguments.length) return colours;\n        colours = _;\n        return chart;\n    };\n\n    chart.fontSize = function(_) {\n        if (!arguments.length) return fontSize;\n        fontSize = _;\n        return chart;\n    };\n\n    chart.duration = function(_) {\n        if (!arguments.length) return duration;\n        duration = _;\n        return chart;\n    };\n\n    chart.layoutFunction = function(_) {\n        if (!arguments.length) return layoutFunction;\n        layoutFunction = _;\n        return chart;\n    };\n\n    chart.normalize = function(_) {\n        if (!arguments.length) return normalize;\n        normalize = _;\n        return chart;\n    };\n\n    chart.styled = function(_) {\n        if (!arguments.length) return styled;\n        styled = _;\n        return chart;\n    };\n\n    chart.orientation = function(_) {\n        if (!arguments.length) return orientation;\n        orientation = _;\n        return chart;\n    };\n\n    chart.orientationOrder = function(_) {\n        if (!arguments.length) return orientationOrder;\n        orientationOrder = _;\n        return chart;\n    };\n\n    chart.lossFunction = function(_) {\n      if (!arguments.length) return loss;\n      loss = _;\n      return chart;\n    };\n\n    return chart;\n}\n// sometimes text doesn't fit inside the circle, if thats the case lets wrap\n// the text here such that it fits\n// todo: looks like this might be merged into d3 (\n// https://github.com/mbostock/d3/issues/1642),\n// also worth checking out is\n// http://engineering.findthebest.com/wrapping-axis-labels-in-d3-js/\n// this seems to be one of those things that should be easy but isn't\nexport function wrapText(circles, labeller) {\n    return function() {\n        var text = select(this),\n            data = text.datum(),\n            width = circles[data.sets[0]].radius || 50,\n            label = labeller(data) || '';\n\n            var words = label.split(/\\s+/).reverse(),\n            maxLines = 3,\n            minChars = (label.length + words.length) / maxLines,\n            word = words.pop(),\n            line = [word],\n            joined,\n            lineNumber = 0,\n            lineHeight = 1.1, // ems\n            tspan = text.text(null).append(\"tspan\").text(word);\n\n        while (true) {\n            word = words.pop();\n            if (!word) break;\n            line.push(word);\n            joined = line.join(\" \");\n            tspan.text(joined);\n            if (joined.length > minChars && tspan.node().getComputedTextLength() > width) {\n                line.pop();\n                tspan.text(line.join(\" \"));\n                line = [word];\n                tspan = text.append(\"tspan\").text(word);\n                lineNumber++;\n            }\n        }\n\n        var initial = 0.35 - lineNumber * lineHeight / 2,\n            x = text.attr(\"x\"),\n            y = text.attr(\"y\");\n\n        text.selectAll(\"tspan\")\n            .attr(\"x\", x)\n            .attr(\"y\", y)\n            .attr(\"dy\", function(d, i) {\n                 return (initial + i * lineHeight) + \"em\";\n            });\n    };\n}\n\nfunction circleMargin(current, interior, exterior) {\n    var margin = interior[0].radius - distance(interior[0], current), i, m;\n    for (i = 1; i < interior.length; ++i) {\n        m = interior[i].radius - distance(interior[i], current);\n        if (m <= margin) {\n            margin = m;\n        }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n        m = distance(exterior[i], current) - exterior[i].radius;\n        if (m <= margin) {\n            margin = m;\n        }\n    }\n    return margin;\n}\n\n// compute the center of some circles by maximizing the margin of\n// the center point relative to the circles (interior) after subtracting\n// nearby circles (exterior)\nexport function computeTextCentre(interior, exterior) {\n    // get an initial estimate by sampling around the interior circles\n    // and taking the point with the biggest margin\n    var points = [], i;\n    for (i = 0; i < interior.length; ++i) {\n        var c = interior[i];\n        points.push({x: c.x, y: c.y});\n        points.push({x: c.x + c.radius/2, y: c.y});\n        points.push({x: c.x - c.radius/2, y: c.y});\n        points.push({x: c.x, y: c.y + c.radius/2});\n        points.push({x: c.x, y: c.y - c.radius/2});\n    }\n    var initial = points[0], margin = circleMargin(points[0], interior, exterior);\n    for (i = 1; i < points.length; ++i) {\n        var m = circleMargin(points[i], interior, exterior);\n        if (m >= margin) {\n            initial = points[i];\n            margin = m;\n        }\n    }\n\n    // maximize the margin numerically\n    var solution = nelderMead(\n                function(p) { return -1 * circleMargin({x: p[0], y: p[1]}, interior, exterior); },\n                [initial.x, initial.y],\n                {maxIterations:500, minErrorDelta:1e-10}).x;\n    var ret = {x: solution[0], y: solution[1]};\n\n    // check solution, fallback as needed (happens if fully overlapped\n    // etc)\n    var valid = true;\n    for (i = 0; i < interior.length; ++i) {\n        if (distance(ret, interior[i]) > interior[i].radius) {\n            valid = false;\n            break;\n        }\n    }\n\n    for (i = 0; i < exterior.length; ++i) {\n        if (distance(ret, exterior[i]) < exterior[i].radius) {\n            valid = false;\n            break;\n        }\n    }\n\n    if (!valid) {\n        if (interior.length == 1) {\n            ret = {x: interior[0].x, y: interior[0].y};\n        } else {\n            var areaStats = {};\n            intersectionArea(interior, areaStats);\n\n            if (areaStats.arcs.length === 0) {\n                ret = {'x': 0, 'y': -1000, disjoint:true};\n\n            } else if (areaStats.arcs.length == 1) {\n                ret = {'x': areaStats.arcs[0].circle.x,\n                       'y': areaStats.arcs[0].circle.y};\n\n            } else if (exterior.length) {\n                // try again without other circles\n                ret = computeTextCentre(interior, []);\n\n            } else {\n                // take average of all the points in the intersection\n                // polygon. this should basically never happen\n                // and has some issues:\n                // https://github.com/benfred/venn.js/issues/48#issuecomment-146069777\n                ret = getCenter(areaStats.arcs.map(function (a) { return a.p1; }));\n            }\n        }\n    }\n\n    return ret;\n}\n\n// given a dictionary of {setid : circle}, returns\n// a dictionary of setid to list of circles that completely overlap it\nfunction getOverlappingCircles(circles) {\n    var ret = {}, circleids = [];\n    for (var circleid in circles) {\n        circleids.push(circleid);\n        ret[circleid] = [];\n    }\n    for (var i  = 0; i < circleids.length; i++) {\n        var a = circles[circleids[i]];\n        for (var j = i + 1; j < circleids.length; ++j) {\n            var b = circles[circleids[j]],\n                d = distance(a, b);\n\n            if (d + b.radius <= a.radius + 1e-10) {\n                ret[circleids[j]].push(circleids[i]);\n\n            } else if (d + a.radius <= b.radius + 1e-10) {\n                ret[circleids[i]].push(circleids[j]);\n            }\n        }\n    }\n    return ret;\n}\n\nexport function computeTextCentres(circles, areas) {\n    var ret = {}, overlapped = getOverlappingCircles(circles);\n    for (var i = 0; i < areas.length; ++i) {\n        var area = areas[i].sets, areaids = {}, exclude = {};\n        for (var j = 0; j < area.length; ++j) {\n            areaids[area[j]] = true;\n            var overlaps = overlapped[area[j]];\n            // keep track of any circles that overlap this area,\n            // and don't consider for purposes of computing the text\n            // centre\n            for (var k = 0; k < overlaps.length; ++k) {\n                exclude[overlaps[k]] = true;\n            }\n        }\n\n        var interior = [], exterior = [];\n        for (var setid in circles) {\n            if (setid in areaids) {\n                interior.push(circles[setid]);\n            } else if (!(setid in exclude)) {\n                exterior.push(circles[setid]);\n            }\n        }\n        var centre = computeTextCentre(interior, exterior);\n        ret[area] = centre;\n        if (centre.disjoint && (areas[i].size > 0)) {\n            console.log(\"WARNING: area \" + area + \" not represented on screen\");\n        }\n    }\n    return  ret;\n}\n\n// sorts all areas in the venn diagram, so that\n// a particular area is on top (relativeTo) - and\n// all other areas are so that the smallest areas are on top\nexport function sortAreas(div, relativeTo) {\n\n    // figure out sets that are completly overlapped by relativeTo\n    var overlaps = getOverlappingCircles(div.selectAll(\"svg\").datum());\n    var exclude = {};\n    for (var i = 0; i < relativeTo.sets.length; ++i) {\n        var check = relativeTo.sets[i];\n        for (var setid in overlaps) {\n            var overlap = overlaps[setid];\n            for (var j = 0; j < overlap.length; ++j) {\n                if (overlap[j] == check) {\n                    exclude[setid] = true;\n                    break;\n                }\n            }\n        }\n    }\n\n    // checks that all sets are in exclude;\n    function shouldExclude(sets) {\n        for (var i = 0; i < sets.length; ++i) {\n            if (!(sets[i] in exclude)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    // need to sort div's so that Z order is correct\n    div.selectAll(\"g\").sort(function (a, b) {\n        // highest order set intersections first\n        if (a.sets.length != b.sets.length) {\n            return a.sets.length - b.sets.length;\n        }\n\n        if (a == relativeTo) {\n            return shouldExclude(b.sets) ? -1 : 1;\n        }\n        if (b == relativeTo) {\n            return shouldExclude(a.sets) ? 1 : -1;\n        }\n\n        // finally by size\n        return b.size - a.size;\n    });\n}\n\nexport function circlePath(x, y, r) {\n    var ret = [];\n    ret.push(\"\\nM\", x, y);\n    ret.push(\"\\nm\", -r, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0, r *2, 0);\n    ret.push(\"\\na\", r, r, 0, 1, 0,-r *2, 0);\n    return ret.join(\" \");\n}\n\n// inverse of the circlePath function, returns a circle object from an svg path\nexport function circleFromPath(path) {\n    var tokens = path.split(' ');\n    return {'x' : parseFloat(tokens[1]),\n            'y' : parseFloat(tokens[2]),\n            'radius' : -parseFloat(tokens[4])\n            };\n}\n\n/** returns a svg path of the intersection area of a bunch of circles */\nexport function intersectionAreaPath(circles) {\n    var stats = {};\n    intersectionArea(circles, stats);\n    var arcs = stats.arcs;\n\n    if (arcs.length === 0) {\n        return \"M 0 0\";\n\n    } else if (arcs.length == 1) {\n        var circle = arcs[0].circle;\n        return circlePath(circle.x, circle.y, circle.radius);\n\n    } else {\n        // draw path around arcs\n        var ret = [\"\\nM\", arcs[0].p2.x, arcs[0].p2.y];\n        for (var i = 0; i < arcs.length; ++i) {\n            var arc = arcs[i], r = arc.circle.radius, wide = arc.width > r;\n            ret.push(\"\\nA\", r, r, 0, wide ? 1 : 0, 1,\n                     arc.p1.x, arc.p1.y);\n        }\n        return ret.join(\" \");\n    }\n}\n","import type { DataItem } from \"../../core/render/Component\";\nimport type { ILegendDataItem } from \"../../core/render/Legend\";\nimport type { Color } from \"../../core/util/Color\";\nimport type { ColorSet } from \"../../core/util/ColorSet\";\nimport type { Pattern } from \"../../core/render/patterns/Pattern\";\nimport type { PatternSet } from \"../../core/util/PatternSet\";\n\nimport { VennDefaultTheme } from \"./VennDefaultTheme\";\nimport { Series, ISeriesSettings, ISeriesDataItem, ISeriesPrivate } from \"../../core/render/Series\";\nimport { Template } from \"../../core/util/Template\";\nimport { Graphics, visualSettings } from \"../../core/render/Graphics\";\nimport { Container } from \"../../core/render/Container\";\nimport { Label } from \"../../core/render/Label\";\nimport { ListTemplate } from \"../../core/util/List\";\n\nimport * as $utils from \"../../core/util/Utils\";\nimport * as $array from \"../../core/util/Array\";\nimport * as $type from \"../../core/util/Type\";\nimport * as venn from \"./vennjs/index.js\";\n\nexport interface IVennDataItem extends ISeriesDataItem {\n\n\t/**\n\t * Array of categories that this data item is an intersection for.\n\t */\n\tintersections: Array<string>;\n\n\t/**\n\t * Category.\n\t */\n\tcategory: string;\n\n\t/**\n\t * Slice visaul element.\n\t */\n\tslice: Graphics;\n\n\t/**\n\t * Slice label.\n\t */\n\tlabel: Label;\n\n\t/**\n\t * A related legend data item.\n\t */\n\tlegendDataItem: DataItem<ILegendDataItem>;\n\n\t/**\n\t * Fill color used for the slice and related elements, e.g. legend marker.\n\t */\n\tfill: Color;\n\n\t/**\n\t * Fill pattern used for the slice and related elements, e.g. legend marker.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/} for more info\n\t * @since 5.10.0\n\t */\n\tfillPattern: Pattern;\n\n}\n\nexport interface IVennSettings extends ISeriesSettings {\n\n\t/**\n\t * A field in data that holds array of categories that overlap.\n\t */\n\tintersectionsField?: string;\n\n\t/**\n\t * A [[ColorSet]] to use when asigning colors for slices.\n\t */\n\tcolors?: ColorSet;\n\n\t/**\n\t * A [[PatternSet]] to use when asigning patterns for slices.\n\t *\n\t * @see {@link https://www.amcharts.com/docs/v5/concepts/colors-gradients-and-patterns/patterns/#Pattern_sets} for more info\n\t * @since 5.10.0\n\t */\n\tpatterns?: PatternSet;\n\n\t/**\n\t * A field in data that holds category names.\n\t */\n\tcategoryField?: string;\n\n\t/**\n\t * A field that holds color for slice fill.\n\t */\n\tfillField?: string;\n\n}\n\nexport interface IVennPrivate extends ISeriesPrivate {\n}\n\n/**\n * Creates a Venn diagram.\n *\n * @see {@link https://www.amcharts.com/docs/v5/charts/venn/} for more info\n * @important\n */\nexport class Venn extends Series {\n\n\tpublic static className: string = \"Venn\";\n\tpublic static classNames: Array<string> = Series.classNames.concat([Venn.className]);\n\n\tdeclare public _settings: IVennSettings;\n\tdeclare public _privateSettings: IVennPrivate;\n\tdeclare public _dataItemSettings: IVennDataItem;\n\n\tprotected _sets: string = \"\";\n\n\t/**\n\t * A [[Container]] that holds all slices (circles and intersections).\n\t *\n\t * @default Container.new()\n\t */\n\tpublic readonly slicesContainer = this.children.push(Container.new(this._root, {}));\n\n\t/**\n\t * A [[Container]] that holds all labels.\n\t *\n\t * @default Container.new()\n\t */\n\tpublic readonly labelsContainer = this.children.push(Container.new(this._root, {}));\n\n\t/**\n\t * A [[Graphics]] element that is used to show the shape of the hovered slice\n\t * or intersection.\n\t *\n\t * @default Graphics.new()\n\t */\n\tpublic readonly hoverGraphics = this.slicesContainer.children.push(Graphics.new(this._root, { position: \"absolute\", isMeasured: false }))\n\n\tprotected _hovered?: Graphics;\n\n\tprotected _afterNew() {\n\t\tthis._defaultThemes.push(VennDefaultTheme.new(this._root));\n\t\tthis.fields.push(\"intersections\", \"category\", \"fill\");\n\t\tsuper._afterNew();\n\t}\n\n\n\t/**\n\t * A [[ListTemplate]] of all slices in series.\n\t *\n\t * `slices.template` can also be used to configure slices.\n\t */\n\tpublic readonly slices: ListTemplate<Graphics> = this.addDisposer(this._makeSlices());\n\n\n\t/**\n\t * @ignore\n\t */\n\tpublic makeSlice(dataItem: DataItem<this[\"_dataItemSettings\"]>): Graphics {\n\t\tconst slice = this.slicesContainer.children.push(this.slices.make());\n\t\tslice.events.on(\"pointerover\", (e) => {\n\t\t\tthis._hovered = e.target;\n\t\t\tthis._updateHover();\n\t\t})\n\n\t\tslice.events.on(\"pointerout\", () => {\n\t\t\tthis._hovered = undefined;\n\t\t\tthis.hoverGraphics.hide();\n\t\t})\n\n\t\tslice.on(\"fill\", () => {\n\t\t\tthis.updateLegendMarker(dataItem);\n\t\t})\n\n\t\tslice.on(\"fillPattern\", () => {\n\t\t\tthis.updateLegendMarker(dataItem);\n\t\t})\n\n\t\tslice.on(\"stroke\", () => {\n\t\t\tthis.updateLegendMarker(dataItem);\n\t\t})\n\n\t\tslice._setDataItem(dataItem);\n\t\tdataItem.set(\"slice\", slice);\n\t\tthis.slices.push(slice);\n\n\t\treturn slice;\n\t}\n\n\tprotected _updateHover() {\n\t\tif (this._hovered) {\n\t\t\tconst hoverGraphics = this.hoverGraphics;\n\t\t\thoverGraphics.set(\"svgPath\", this._hovered.get(\"svgPath\"));\n\t\t\thoverGraphics.show();\n\t\t\thoverGraphics.toFront();\n\t\t}\n\t}\n\n\t/**\n\t * A [[ListTemplate]] of all slice labels in series.\n\t *\n\t * `labels.template` can also be used to configure slice labels.\n\t */\n\tpublic readonly labels: ListTemplate<Label> = this.addDisposer(this._makeLabels());\n\n\t/**\n\t * @ignore\n\t */\n\tpublic makeLabel(dataItem: DataItem<this[\"_dataItemSettings\"]>): Label {\n\t\tconst label = this.labelsContainer.children.push(this.labels.make());\n\t\tlabel._setDataItem(dataItem);\n\t\tdataItem.set(\"label\", label);\n\t\tthis.labels.push(label);\n\t\treturn label;\n\t}\n\n\n\tprotected _makeSlices(): ListTemplate<Graphics> {\n\t\treturn new ListTemplate(\n\t\t\tTemplate.new({}),\n\t\t\t() => Graphics._new(this._root, {\n\t\t\t\tthemeTags: $utils.mergeTags(this.slices.template.get(\"themeTags\", []), [\"venn\", \"series\"])\n\t\t\t}, [this.slices.template]),\n\t\t);\n\t}\n\n\tprotected _makeLabels(): ListTemplate<Label> {\n\t\treturn new ListTemplate(\n\t\t\tTemplate.new({}),\n\t\t\t() => Label._new(this._root, {\n\t\t\t\tthemeTags: $utils.mergeTags(this.labels.template.get(\"themeTags\", []), [\"venn\", \"series\"])\n\t\t\t}, [this.labels.template]),\n\t\t);\n\t}\n\n\n\tprotected processDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tsuper.processDataItem(dataItem);\n\n\n\t\tif (dataItem.get(\"fill\") == null) {\n\t\t\tlet colors = this.get(\"colors\");\n\t\t\tif (colors) {\n\t\t\t\tdataItem.setRaw(\"fill\", colors.next());\n\t\t\t}\n\t\t}\n\n\t\tif (dataItem.get(\"fillPattern\") == null) {\n\t\t\tlet patterns = this.get(\"patterns\");\n\t\t\tif (patterns) {\n\t\t\t\tdataItem.setRaw(\"fillPattern\", patterns.next());\n\t\t\t}\n\t\t}\n\n\t\tthis.makeSlice(dataItem);\n\t\tthis.makeLabel(dataItem);\n\t}\n\n\tpublic _prepareChildren() {\n\t\tsuper._prepareChildren();\n\n\t\tif (this._valuesDirty || this._sizeDirty) {\n\t\t\tconst sets: any[] = [];\n\n\t\t\t// prepare data for venn\n\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\tconst set: any = {};\n\t\t\t\tconst intersections = dataItem.get(\"intersections\");\n\t\t\t\tif (intersections) {\n\t\t\t\t\tset.sets = intersections;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tset.sets = [dataItem.get(\"category\")];\n\t\t\t\t}\n\t\t\t\tset.size = dataItem.get(\"valueWorking\");\n\n\t\t\t\t//if (set.size > 0) { // not good\n\t\t\t\tsets.push(set);\n\t\t\t\t//}\n\n\t\t\t\tconst label = dataItem.get(\"label\");\n\t\t\t\tconst slice = dataItem.get(\"slice\");\n\n\n\t\t\t\tlet visible = true;\n\t\t\t\tif (dataItem.get(\"value\") == 0) {\n\t\t\t\t\tvisible = false;\n\n\t\t\t\t\tif (slice) {\n\t\t\t\t\t\tslice.setAll({\n\t\t\t\t\t\t\tx: this.width() / 2,\n\t\t\t\t\t\t\ty: this.height() / 2\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (label) {\n\t\t\t\t\tlabel.setPrivate(\"visible\", visible);\n\t\t\t\t}\n\t\t\t})\n\n\n\t\t\tconst newSets = sets.toString();\n\n\t\t\tthis._sets = newSets;\n\n\t\t\tif (sets.length > 0) {\n\t\t\t\tlet vennData = venn.venn(sets);\n\t\t\t\tvennData = venn.normalizeSolution(vennData, null, null);\n\t\t\t\tvennData = venn.scaleSolution(vennData, this.innerWidth(), this.innerHeight(), 0);\n\n\t\t\t\tconst circles: any = {};\n\t\t\t\tfor (let name in vennData) {\n\t\t\t\t\tlet item = vennData[name];\n\t\t\t\t\tlet r = item.radius;\n\n\t\t\t\t\tconst dataItem = this.getDataItemByCategory(name);\n\t\t\t\t\tif (dataItem) {\n\t\t\t\t\t\tconst slice = dataItem.get(\"slice\");\n\t\t\t\t\t\tconst color = dataItem.get(\"fill\");\n\t\t\t\t\t\tslice._setDefault(\"fill\", color);\n\n\t\t\t\t\t\tconst fillPattern = dataItem.get(\"fillPattern\");\n\t\t\t\t\t\tslice._setDefault(\"fillPattern\", fillPattern);\n\n\t\t\t\t\t\tslice._setDefault(\"stroke\", color);\n\n\t\t\t\t\t\tthis.updateLegendMarker(dataItem);\n\n\t\t\t\t\t\tslice.set(\"svgPath\", \"M\" + item.x + \",\" + item.y + \" m -\" + r + \", 0 a \" + r + \",\" + r + \" 0 1,1 \" + r * 2 + \",0 a \" + r + \",\" + r + \" 0 1,1 -\" + r * 2 + \",0\");\n\t\t\t\t\t\tcircles[name] = item;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tlet centers: any = venn.computeTextCentres(circles, sets);\n\n\n\t\t\t\t$array.each(this.dataItems, (dataItem) => {\n\t\t\t\t\tlet name = dataItem.get(\"category\");\n\t\t\t\t\tlet center = centers[name];\n\t\t\t\t\tconst intersections = dataItem.get(\"intersections\");\n\t\t\t\t\tif (intersections) {\n\t\t\t\t\t\tname = intersections.toString();\n\t\t\t\t\t\tcenter = centers[name];\n\t\t\t\t\t\tif (center) {\n\t\t\t\t\t\t\tlet set = intersections;\n\t\t\t\t\t\t\tlet cc = [];\n\n\t\t\t\t\t\t\tfor (let s = 0; s < set.length; s++) {\n\t\t\t\t\t\t\t\tcc.push(circles[set[s]]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet intersectionPath = venn.intersectionAreaPath(cc)\n\t\t\t\t\t\t\tlet slice = dataItem.get(\"slice\");\n\n\t\t\t\t\t\t\tconst color = dataItem.get(\"fill\");\n\t\t\t\t\t\t\tslice._setDefault(\"fill\", color);\n\t\t\t\t\t\t\tslice._setDefault(\"stroke\", color);\n\n\t\t\t\t\t\t\tconst fillPattern = dataItem.get(\"fillPattern\");\n\t\t\t\t\t\t\tslice._setDefault(\"fillPattern\", fillPattern);\n\n\t\t\t\t\t\t\tslice.setAll({ svgPath: intersectionPath });\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (center) {\n\t\t\t\t\t\tlet label = dataItem.get(\"label\");\n\t\t\t\t\t\tlabel.setAll({ x: center.x, y: center.y });\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.updateLegendValue(dataItem);\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tthis._updateHover();\n\t\t}\n\t}\n\n\t/**\n\t * Looks up and returns a data item by its category.\n\t *\n\t * @param   category  Category\n\t * @return      Data item\n\t */\n\tpublic getDataItemByCategory(id: string): DataItem<this[\"_dataItemSettings\"]> | undefined {\n\t\treturn $array.find(this.dataItems, (dataItem: any) => {\n\t\t\treturn dataItem.get(\"category\") == id;\n\t\t})\n\t}\n\n\n\t/**\n\t * Shows series's data item.\n\t *\n\t * @param   dataItem  Data item\n\t * @param   duration  Animation duration in milliseconds\n\t * @return            Promise\n\t */\n\tpublic async showDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, duration?: number): Promise<void> {\n\t\tconst promises = [super.showDataItem(dataItem, duration)];\n\t\tif (!$type.isNumber(duration)) {\n\t\t\tduration = this.get(\"stateAnimationDuration\", 0);\n\t\t}\n\n\t\tconst easing = this.get(\"stateAnimationEasing\");\n\n\t\tlet value = dataItem.get(\"value\");\n\n\t\tconst animation = dataItem.animate({ key: \"valueWorking\", to: value, duration: duration, easing: easing });\n\t\tif (animation) {\n\t\t\tpromises.push(animation.waitForStop());\n\t\t}\n\n\t\tconst label = dataItem.get(\"label\");\n\t\tif (label) {\n\t\t\tpromises.push(label.show(duration));\n\t\t}\n\n\t\tconst slice = dataItem.get(\"slice\");\n\t\tif (slice) {\n\t\t\tpromises.push(slice.show(duration));\n\t\t}\n\n\n\t\tconst intersections = dataItem.get(\"intersections\");\n\t\tif (intersections) {\n\t\t\t$array.each(intersections, (cat) => {\n\t\t\t\tconst di = this.getDataItemByCategory(cat);\n\t\t\t\tif (di && di.isHidden()) {\n\t\t\t\t\tthis.showDataItem(di, duration);\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tif (!intersections) {\n\t\t\tconst category = dataItem.get(\"category\");\n\n\t\t\t$array.each(this.dataItems, (di) => {\n\t\t\t\tconst intersections = di.get(\"intersections\");\n\t\t\t\tif (di != dataItem && intersections) {\n\t\t\t\t\tlet allVisible = true;\n\t\t\t\t\t$array.each(intersections, (cat) => {\n\t\t\t\t\t\tconst dii = this.getDataItemByCategory(cat);\n\t\t\t\t\t\tif (dii && dii.isHidden()) {\n\t\t\t\t\t\t\tallVisible = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\n\t\t\t\t\tif (allVisible && intersections.indexOf(category) != -1) {\n\t\t\t\t\t\tif (di.isHidden()) {\n\t\t\t\t\t\t\tthis.showDataItem(di, duration);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * Hides series's data item.\n\t *\n\t * @param   dataItem  Data item\n\t * @param   duration  Animation duration in milliseconds\n\t * @return            Promise\n\t */\n\tpublic async hideDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>, duration?: number): Promise<void> {\n\t\tconst promises = [super.hideDataItem(dataItem, duration)];\n\t\tconst hiddenState = this.states.create(\"hidden\", {})\n\n\t\tif (!$type.isNumber(duration)) {\n\t\t\tduration = hiddenState.get(\"stateAnimationDuration\", this.get(\"stateAnimationDuration\", 0));\n\t\t}\n\n\t\tconst easing = hiddenState.get(\"stateAnimationEasing\", this.get(\"stateAnimationEasing\"));\n\n\t\tconst animation = dataItem.animate({ key: \"valueWorking\", to: 0, duration: duration, easing: easing });\n\t\tif (animation) {\n\t\t\tpromises.push(animation.waitForStop());\n\t\t}\n\n\t\tconst label = dataItem.get(\"label\");\n\t\tif (label) {\n\t\t\tpromises.push(label.hide(duration));\n\t\t}\n\n\t\tconst slice = dataItem.get(\"slice\");\n\t\tif (slice) {\n\t\t\tpromises.push(slice.hide(duration));\n\t\t\tslice.hideTooltip();\n\t\t}\n\n\t\tif (!dataItem.get(\"intersections\")) {\n\t\t\t$array.each(this.dataItems, (di) => {\n\t\t\t\tconst intersections = di.get(\"intersections\");\n\t\t\t\tif (di != dataItem && intersections) {\n\t\t\t\t\tif (intersections.indexOf(dataItem.get(\"category\")) != -1) {\n\t\t\t\t\t\tthis.hideDataItem(di, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\n\t\tawait Promise.all(promises);\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic disposeDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tsuper.disposeDataItem(dataItem);\n\t\tlet label = dataItem.get(\"label\");\n\t\tif (label) {\n\t\t\tthis.labels.removeValue(label);\n\t\t\tlabel.dispose();\n\t\t}\n\n\t\tlet slice = dataItem.get(\"slice\");\n\t\tif (slice) {\n\t\t\tthis.slices.removeValue(slice);\n\t\t\tslice.dispose();\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t */\n\tpublic updateLegendMarker(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tconst slice = dataItem.get(\"slice\");\n\n\t\tif (slice) {\n\t\t\tconst legendDataItem = dataItem.get(\"legendDataItem\");\n\t\t\tif (legendDataItem) {\n\t\t\t\tconst markerRectangle = legendDataItem.get(\"markerRectangle\");\n\t\t\t\tif (!dataItem.isHidden()) {\n\t\t\t\t\t$array.each(visualSettings, (setting: any) => {\n\t\t\t\t\t\tmarkerRectangle.set(setting, slice.get(setting));\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Triggers hover on a series data item.\n\t *\n\t * @since 5.0.7\n\t * @param  dataItem  Target data item\n\t */\n\tpublic hoverDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tconst slice = dataItem.get(\"slice\");\n\t\tif (slice && !slice.isHidden()) {\n\t\t\tslice.hover();\n\t\t}\n\t}\n\n\t/**\n\t * Triggers un-hover on a series data item.\n\t *\n\t * @since 5.0.7\n\t * @param  dataItem  Target data item\n\t */\n\tpublic unhoverDataItem(dataItem: DataItem<this[\"_dataItemSettings\"]>) {\n\t\tconst slice = dataItem.get(\"slice\");\n\t\tif (slice) {\n\t\t\tslice.unhover();\n\t\t}\n\t}\n}\n"],"sourceRoot":""}